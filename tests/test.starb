
scope Core {
    decl greeting:String = "hello_scope"

    func makeWord() String {
        return "scope-fn"
    }

    scope Math {
        func answer() Int {
            return 42
        }
    }
}

scope Models {
    class Pet {
        decl name:String

        func getKind() String {
            return "pet"
        }
    }

    class Ticket {
        decl code:String = "unset"
        decl owner:String = "n/a"

        new(owner:String){
            self.owner = owner
            self.code = "issued"
        }

        func summary() String {
            return self.code
        }
    }

    class Counter {
        decl value:Int = 10

        new(start:Int){
            self.value = start
        }
    }
}

interface Named {
    decl name:String

    func getName() String {
        return "named"
    }
}

@deprecated("Legacy model")
class Person : Named {
    @readonly
    decl id:String
    decl name:String

    @native(name="person_getName")
    func getName() String {
        return "person"
    }
}

decl p = new Person()
p.name = "alextopper"
print(p.name)
print(p.getName())

decl scopedPet = new Models.Pet()
scopedPet.name = "milo"
print(scopedPet.name)
print(scopedPet.getKind())
decl ticket = new Models.Ticket("alex")
print(ticket.owner)
print(ticket.code)
print(ticket.summary())
decl counter = new Models.Counter(21)
print(counter.value)
print(Core.greeting)
print(Core.makeWord())
print(Core.Math.answer())



func myFunc(){
    return "this test!"
}

decl myvar = ["hello","world"]
decl myvar2 = myFunc()
decl foo = 34.12
decl bar = false
decl imut myConst = 4

print(bar)
print(myvar2)
print(foo)
print(myConst)

if(bar){
	
    print("YES")
}
else {
    print("NO")
}

class LoopState {
    decl run:Bool = true
}

decl whileState = new LoopState()
while(whileState.run){
    print("WHILE-ONCE")
    whileState.run = false
}

decl forState = new LoopState()
for(forState.run){
    print("FOR-ONCE")
    forState.run = false
}

if(bar){
    print("IF-BRANCH")
}
elif(forState.run){
    print("ELIF-BRANCH")
}
else {
    print("ELSE-BRANCH")
}

func maybeName() String? {
    return "optional-value"
}

func riskyName() String! {
    return "throwable-value"
}

secure(decl optionalValue = maybeName()) catch {
    print("OPTIONAL-CATCH")
}
print(optionalValue)

secure(decl throwableValue = riskyName()) catch {
    print("THROW-CATCH")
}
print(throwableValue)

decl missingValue:String?
secure(decl recoveredValue = missingValue) catch (error:String) {
    print("SECURE-CATCH")
}

secure(decl compiledRegex = /(?:word1|word2)/gm) catch (error:String) {
    print("REGEX-CATCH")
    print(error)
}
print(compiledRegex)

secure(decl badRegex = /(/g) catch (error:String) {
    print("REGEX-ERROR")
    print(error)
}

decl mathA:Int = 10
decl mathB:Int = 4
decl arithmetic = (mathA + mathB) * 2 - 3
print(arithmetic)
mathA += mathB
print(mathA)
mathA *= 2
print(mathA)
mathA /= 4
print(mathA)
mathA %= 4
print(mathA)
mathA &= 7
print(mathA)
mathA |= 2
print(mathA)
mathA ^= 1
print(mathA)
mathA <<= 1
print(mathA)
mathA >>= 2
print(mathA)
print(~mathA)
print(+mathA)

decl concat = "sum:" + arithmetic
print(concat)

if((arithmetic >= 25 && mathB < 10) || (mathA == 0)){
    print("OP-COND-YES")
}
else {
    print("OP-COND-NO")
}

decl bucket = {"name":"starbytes","score":42}
print(bucket["name"])
bucket["score"] = bucket["score"] + 1
print(bucket["score"])
bucket["enabled"] = true
if(bucket["enabled"] == true){
    print("DICT-COND-YES")
}

decl seq = [1,2,3]
seq[1] = 9
print(seq[1])

def Score = Int

interface Boxable<T> {
    decl value:T

    func ready() Bool {
        return true
    }
}

class Box<T> : Boxable<T> {
    decl value:T

    new(v:T){
        self.value = v
    }

    func get() T {
        return self.value
    }

    func ready() Bool {
        return true
    }
}

class Animal {
    decl name:String = "animal"

    func getName() String {
        return self.name
    }
}

class Dog : Animal {
    new(){
        self.name = "dog"
    }
}

decl scoreValue:Score = 11
print(scoreValue)

decl boxed = new Box<String>("spark")
print(boxed.get())

decl dog = new Dog()
print(dog.getName())
print(dog.name)

struct Point {
    decl x:Int = 1
    decl imut label:String = "pt"
}

enum Priority {
    LOW
    MEDIUM = 3
    HIGH
}

decl point = new Point()
print(point.x)
point.x = 7
print(point.x)
print(point.label)

print(Priority.LOW)
print(Priority.MEDIUM)
print(Priority.HIGH)

lazy delayedGreeting(name:String) String {
    return "hello " + name
}

lazy func badRegexTask() Regex! {
    return /(/g
}

decl pendingGreeting = delayedGreeting("starbytes")
print(pendingGreeting)
decl greeting = await pendingGreeting
print(greeting)

decl typedTask:Task<String> = delayedGreeting("typed")
decl typedGreeting = await typedTask
print(typedGreeting)

decl inlineGreeting = await delayedGreeting("inline")
print(inlineGreeting)

secure(decl failedRegex = await badRegexTask()) catch (error:String) {
    print(error)
}

def AnimalAlias = Animal
def NumAlias = Int
def NumAlias2 = NumAlias

decl intVal:Int = 7
decl floatVal:Float = 7.5
print(intVal is Int)
print(intVal is Float)
print(floatVal is Float)
print(floatVal is Int)
print(intVal is NumAlias)
print(intVal is NumAlias2)
print(intVal is Any)

print(dog is Dog)
print(dog is Animal)
print(dog is AnimalAlias)
print(dog is Any)
print(dog is String)

print(scopedPet is Models.Pet)
print(point is Point)
print(point is Animal)

print(greeting is String)
print(typedTask is Task)

decl rttcCount:Int = 0
while(rttcCount < 64){
    if(((dog is Animal) && (dog is Dog) && (rttcCount is Int)) == false){
        print("RTTC-LOOP-FAIL")
    }
    rttcCount += 1
}
print(rttcCount)
