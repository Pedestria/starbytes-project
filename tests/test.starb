
scope Core {
    decl greeting:String = "hello_scope"

    func makeWord() String {
        return "scope-fn"
    }

    scope Math {
        func answer() Int {
            return 42
        }
    }
}

scope Models {
    class Pet {
        decl name:String

        func getKind() String {
            return "pet"
        }
    }

    class Ticket {
        decl code:String = "unset"
        decl owner:String = "n/a"

        new(owner:String){
            self.owner = owner
            self.code = "issued"
        }

        func summary() String {
            return self.code
        }
    }

    class Counter {
        decl value:Int = 10

        new(start:Int){
            self.value = start
        }
    }
}

interface Named {
    decl name:String

    func getName() String {
        return "named"
    }
}

@deprecated("Legacy model")
class Person : Named {
    @readonly
    decl id:String
    decl name:String

    @native(name="person_getName")
    func getName() String {
        return "person"
    }
}

decl p = new Person()
p.name = "alextopper"
print(p.name)
print(p.getName())

decl scopedPet = new Models.Pet()
scopedPet.name = "milo"
print(scopedPet.name)
print(scopedPet.getKind())
decl ticket = new Models.Ticket("alex")
print(ticket.owner)
print(ticket.code)
print(ticket.summary())
decl counter = new Models.Counter(21)
print(counter.value)
print(Core.greeting)
print(Core.makeWord())
print(Core.Math.answer())



func myFunc(){
    return "this test!"
}

decl myvar = ["hello","world"]
decl myvar2 = myFunc()
decl foo = 34.12
decl bar = false
decl imut myConst = 4

print(bar)
print(myvar2)
print(foo)
print(myConst)

if(bar){
	
    print("YES")
}
else {
    print("NO")
}

class LoopState {
    decl run:Bool = true
}

decl whileState = new LoopState()
while(whileState.run){
    print("WHILE-ONCE")
    whileState.run = false
}

decl forState = new LoopState()
for(forState.run){
    print("FOR-ONCE")
    forState.run = false
}

if(bar){
    print("IF-BRANCH")
}
elif(forState.run){
    print("ELIF-BRANCH")
}
else {
    print("ELSE-BRANCH")
}

func maybeName() String? {
    return "optional-value"
}

func riskyName() String! {
    return "throwable-value"
}

secure(decl optionalValue = maybeName()) catch {
    print("OPTIONAL-CATCH")
}
print(optionalValue)

secure(decl throwableValue = riskyName()) catch {
    print("THROW-CATCH")
}
print(throwableValue)

decl missingValue:String?
secure(decl recoveredValue = missingValue) catch (error:String) {
    print("SECURE-CATCH")
}

secure(decl compiledRegex = /(?:word1|word2)/gm) catch (error:String) {
    print("REGEX-CATCH")
    print(error)
}
print(compiledRegex)

secure(decl badRegex = /(/g) catch (error:String) {
    print("REGEX-ERROR")
    print(error)
}

decl mathA:Int = 10
decl mathB:Int = 4
decl arithmetic = (mathA + mathB) * 2 - 3
print(arithmetic)
mathA += mathB
print(mathA)
mathA *= 2
print(mathA)
mathA /= 4
print(mathA)
mathA %= 4
print(mathA)

decl concat = "sum:" + arithmetic
print(concat)

if((arithmetic >= 25 && mathB < 10) || (mathA == 0)){
    print("OP-COND-YES")
}
else {
    print("OP-COND-NO")
}

decl bucket = {"name":"starbytes","score":42}
print(bucket["name"])
bucket["score"] = bucket["score"] + 1
print(bucket["score"])
bucket["enabled"] = true
if(bucket["enabled"] == true){
    print("DICT-COND-YES")
}

decl seq = [1,2,3]
seq[1] = 9
print(seq[1])

def Score = Int

interface Boxable<T> {
    decl value:T

    func ready() Bool {
        return true
    }
}

class Box<T> : Boxable<T> {
    decl value:T

    new(v:T){
        self.value = v
    }

    func get() T {
        return self.value
    }

    func ready() Bool {
        return true
    }
}

class Animal {
    decl name:String = "animal"

    func getName() String {
        return self.name
    }
}

class Dog : Animal {
    new(){
        self.name = "dog"
    }
}

decl scoreValue:Score = 11
print(scoreValue)

decl boxed = new Box<String>("spark")
print(boxed.get())

decl dog = new Dog()
print(dog.getName())
print(dog.name)
