
scope Core {
    decl greeting:String = "hello_scope"

    func makeWord() String {
        return "scope-fn"
    }

    scope Math {
        func answer() Int {
            return 42
        }
    }
}

scope Models {
    class Pet {
        decl name:String

        func getKind() String {
            return "pet"
        }
    }

    class Ticket {
        decl code:String = "unset"
        decl owner:String = "n/a"

        new(owner:String){
            self.owner = owner
            self.code = "issued"
        }

        func summary() String {
            return self.code
        }
    }

    class Counter {
        decl value:Int = 10

        new(start:Int){
            self.value = start
        }
    }
}

@deprecated("Legacy model")
class Person {
    @readonly
    decl id:String
    decl name:String

    @native(name="person_getName")
    func getName() String {
        return "person"
    }
}

decl p = new Person()
p.name = "alextopper"
print(p.name)
print(p.getName())

decl scopedPet = new Models.Pet()
scopedPet.name = "milo"
print(scopedPet.name)
print(scopedPet.getKind())
decl ticket = new Models.Ticket("alex")
print(ticket.owner)
print(ticket.code)
print(ticket.summary())
decl counter = new Models.Counter(21)
print(counter.value)
print(Core.greeting)
print(Core.makeWord())
print(Core.Math.answer())



func myFunc(){
    return "this test!"
}

decl myvar = ["hello","world"]
decl myvar2 = myFunc()
decl foo = 34.12
decl bar = false
decl imut myConst = 4

print(bar)
print(myvar2)
print(foo)
print(myConst)

if(bar){
	
    print("YES")
}
else {
    print("NO")
}

class LoopState {
    decl run:Bool = true
}

decl whileState = new LoopState()
while(whileState.run){
    print("WHILE-ONCE")
    whileState.run = false
}

decl forState = new LoopState()
for(forState.run){
    print("FOR-ONCE")
    forState.run = false
}

if(bar){
    print("IF-BRANCH")
}
elif(forState.run){
    print("ELIF-BRANCH")
}
else {
    print("ELSE-BRANCH")
}

func maybeName() String? {
    return "optional-value"
}

func riskyName() String! {
    return "throwable-value"
}

secure(decl optionalValue = maybeName()) catch {
    print("OPTIONAL-CATCH")
}
print(optionalValue)

secure(decl throwableValue = riskyName()) catch {
    print("THROW-CATCH")
}
print(throwableValue)

decl missingValue:String?
secure(decl recoveredValue = missingValue) catch (error:String) {
    print("SECURE-CATCH")
}

secure(decl compiledRegex = /(?:word1|word2)/gm) catch (error:String) {
    print("REGEX-CATCH")
    print(error)
}
print(compiledRegex)

secure(decl badRegex = /(/g) catch (error:String) {
    print("REGEX-ERROR")
    print(error)
}



